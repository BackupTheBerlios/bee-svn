
1. Structured data types
-------------------------------------------------------------------------------

    * Linked lists : http://en.wikipedia.org/wiki/Linked_list
        Persistent data structure : http://en.wikipedia.org/wiki/Persistent_data_structure

    * Binary tree : http://en.wikipedia.org/wiki/Binary_tree

    * Huffman's encoding : http://en.wikipedia.org/wiki/Huffman_coding

    * Tree graph : http://en.wikipedia.org/wiki/Tree_graph
        Tree structure : http://en.wikipedia.org/wiki/Tree_structure
        Tree data structure : http://en.wikipedia.org/wiki/Tree_data_structure
        List of graph theory topics : http://en.wikipedia.org/wiki/List_of_graph_theory_topics#Trees


Heaps.
-------------------------------------------------------------------------------
    * Binary heap
    * Binomial heap
    * Fibonacci heap
    * Pairing heap
    * Leftist heap
    * Soft heap
    * 2-3 heap
    * Treap
    * Beap
    * Skew heap


2. Sorting algorithms.
-------------------------------------------------------------------------------

  * Comparison sorts
  * Selection sort
  * Name                Best            Average     Worst       Memory      Stable      Method          Other notes
  * Bubble sort         O(n)            -           O(n2)       O(1)        Yes         Exchanging      Times are for best variant
  * Cocktail sort       O(n)            -           O(n2)       O(1)        Yes         Exchanging
  * Comb sort           O(n log n)      O(n log n)  O(n log n)  O(1)        No          Exchanging
  * Gnome sort          O(n)            -           O(n2)       O(1)        Yes         Exchanging
  * Selection sort      O(n2)           O(n2)       O(n2)       O(1)        No          Selection
  * Insertion sort      O(n)            -           O(n2)       O(1)        Yes         Insertion
  * Shell sort          O(nlog(n))      -           O(nlog2(n)) O(1)        No          Insertion       Times are for best variant
  * Binary tree sort    O(nlog(n))      O(nlog(n))  O(nlog(n))  O(1)        Yes         Insertion
  * Library sort        O(n)            O(nlog(n))  O(n2)       O(n)        Yes         Insertion
  * Merge sort          O(nlog(n))      O(nlog(n))  O(nlog(n))  O(n)        Yes         Merging
  * In-place merge sort O(nlog(n))      O(nlog(n))  O(nlog(n))  O(1)        Yes         Merging         Times are for best variant
  * Heapsort            O(nlog(n))      O(nlog(n))  O(nlog(n))  O(1)        No          Selection
  * Smoothsort          O(n)            -           O(nlog(n))  O(1)        No          Selection
  * Quicksort           O(nlog(n))      O(nlog(n))  O(n2)       O(log n)    No          Partitioning    Naive variants use O(n) space
  * Introsort           O(nlog(n))      O(nlog(n))  O(nlog(n))  O(log n)    No          Hybrid
  * Patience sorting    O(n)            -           O(nlog(n))  O(n)        No          Insertion       Finds all the longest increasing subsequences within O(n log log(n))




3. Searching
-------------------------------------------------------------------------------

Self-balancing binary search tree( AVL )
    * AA tree
    * AVL tree
    * red-black tree
    * splay tree
    * scapegoat tree
    * DSW algorithm
    * skip list
    * b-tree



